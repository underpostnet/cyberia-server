package pathfinding

import (
	"container/heap"
	"fmt"
	"log"
	"math"

	"cyberia-server/network_state" // Updated import path
)

// AStarNode represents a node in the A* algorithm's search space.
// X and Y here represent ABSOLUTE maze coordinates, not wrapped.
type AStarNode struct {
	X, Y   int
	G      float64
	H      float64
	F      float64
	Parent *AStarNode
	Index  int
}

// PriorityQueue implements heap.Interface for AStarNode to manage the open set.
type PriorityQueue []*AStarNode

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
	return pq[i].F < pq[j].F
}

func (pq PriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
	pq[i].Index = i
	pq[j].Index = j
}

func (pq *PriorityQueue) Push(x interface{}) {
	n := len(*pq)
	node := x.(*AStarNode)
	node.Index = n
	*pq = append(*pq, node)
}

func (pq *PriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	node := old[n-1]
	old[n-1] = nil
	node.Index = -1
	*pq = old[0 : n-1]
	return node
}

// heuristic calculates the Manhattan distance between two AStarNodes, considering world wrapping.
// 'a' and 'b' are absolute maze coordinates.
func heuristic(a, b *AStarNode, mazeCellsX, mazeCellsY int) float64 {
	dr := math.Abs(float64(a.Y - b.Y))
	dc := math.Abs(float64(a.X - b.X))

	// Consider wrapping around for rows
	drWrapped := math.Min(dr, float64(mazeCellsY)-dr)
	// Consider wrapping around for columns
	dcWrapped := math.Min(dc, float64(mazeCellsX)-dc)

	return drWrapped + dcWrapped
}

// FindPath calculates an A* path between two world coordinates,
// considering world wrapping for the shortest path.
func FindPath(ns *network_state.NetworkState, startWorldX, startWorldY, endWorldX, endWorldY float64) ([]struct{ X, Y float64 }, error) {
	ns.Mu.RLock()
	defer ns.Mu.RUnlock()

	// Convert start world coordinates to initial absolute maze coordinates
	// For the start, we assume its current world position is its 'absolute' position.
	startMazeX, startMazeY := ns.WorldToAbsoluteMazeCoords(startWorldX, startWorldY)
	startNode := &AStarNode{X: startMazeX, Y: startMazeY, G: 0}

	// Validate start position (using its wrapped version for maze lookup)
	wrappedStartMazeX := (startMazeX % ns.MazeCellsX)
	if wrappedStartMazeX < 0 {
		wrappedStartMazeX += ns.MazeCellsX
	}
	wrappedStartMazeY := (startMazeY % ns.MazeCellsY)
	if wrappedStartMazeY < 0 {
		wrappedStartMazeY += ns.MazeCellsY
	}

	if !(wrappedStartMazeX >= 0 && wrappedStartMazeX < ns.MazeCellsX &&
		wrappedStartMazeY >= 0 && wrappedStartMazeY < ns.MazeCellsY &&
		ns.SimplifiedMaze[wrappedStartMazeY][wrappedStartMazeX] == 0) {
		return nil, fmt.Errorf("start position (maze: %d,%d, wrapped: %d,%d) is invalid or an obstacle", startMazeX, startMazeY, wrappedStartMazeX, wrappedStartMazeY)
	}

	// Convert end world coordinates to its base absolute maze coordinates
	baseEndMazeX, baseEndMazeY := ns.WorldToAbsoluteMazeCoords(endWorldX, endWorldY)

	// Generate candidate absolute end points by considering wrapping around the start point
	// The candidates should be relative to the *absolute* start node.
	// This ensures we find the shortest path even if it wraps multiple times.
	candidateEndNodes := []*AStarNode{}
	for dy_wrap := -1; dy_wrap <= 1; dy_wrap++ {
		for dx_wrap := -1; dx_wrap <= 1; dx_wrap++ {
			// Calculate the absolute maze coordinates of the candidate end point
			// by taking the base end point and adding/subtracting world dimensions
			// in maze units.
			candidateAbsMazeX := baseEndMazeX + dx_wrap*ns.MazeCellsX
			candidateAbsMazeY := baseEndMazeY + dy_wrap*ns.MazeCellsY

			// Check if the wrapped candidate maze cell is walkable (using its normalized coordinates)
			wrappedCandidateMazeX := (candidateAbsMazeX % ns.MazeCellsX)
			if wrappedCandidateMazeX < 0 {
				wrappedCandidateMazeX += ns.MazeCellsX
			}
			wrappedCandidateMazeY := (candidateAbsMazeY % ns.MazeCellsY)
			if wrappedCandidateMazeY < 0 {
				wrappedCandidateMazeY += ns.MazeCellsY
			}

			if ns.SimplifiedMaze[wrappedCandidateMazeY][wrappedCandidateMazeX] == 0 {
				candidateEndNodes = append(candidateEndNodes, &AStarNode{X: candidateAbsMazeX, Y: candidateAbsMazeY})
			}
		}
	}

	if len(candidateEndNodes) == 0 {
		return nil, fmt.Errorf("no valid walkable end positions found, even with wrapping considerations")
	}

	var bestPath []struct{ X, Y float64 }
	minPathLength := math.MaxFloat64

	// Define neighbors (8 directions) once
	neighborsDirs := []struct {
		dx, dy int
		cost   float64
	}{
		{0, 1, 1.0},
		{0, -1, 1.0},
		{1, 0, 1.0},
		{-1, 0, 1.0},
		{1, 1, math.Sqrt2},
		{1, -1, math.Sqrt2},
		{-1, 1, math.Sqrt2},
		{-1, -1, math.Sqrt2},
	}

	for _, candidateEndNode := range candidateEndNodes {
		log.Printf("Pathfinding: Trying path from absolute maze (%d,%d) to candidate absolute (%d,%d)...\n", startNode.X, startNode.Y, candidateEndNode.X, candidateEndNode.Y)

		currentOpenSet := make(PriorityQueue, 0)
		heap.Push(&currentOpenSet, &AStarNode{
			X: startNode.X, Y: startNode.Y, G: 0,
			H: heuristic(startNode, candidateEndNode, ns.MazeCellsX, ns.MazeCellsY),
		})

		gScore := make(map[string]float64)
		gScore[fmt.Sprintf("%d,%d", startNode.X, startNode.Y)] = 0

		cameFrom := make(map[string]*AStarNode)

		maxIterations := (ns.MazeCellsX * ns.MazeCellsY * 2) // A safety break to prevent infinite loops
		iterations := 0

		for currentOpenSet.Len() > 0 {
			iterations++
			if iterations > maxIterations {
				log.Printf("WARNING: Pathfinding for candidate absolute (%d,%d) aborted due to too many iterations.", candidateEndNode.X, candidateEndNode.Y)
				break // Break from inner loop, try next candidate
			}

			current := heap.Pop(&currentOpenSet).(*AStarNode)
			currentKey := fmt.Sprintf("%d,%d", current.X, current.Y)

			// Retrieve the gScore for the current node. It MUST exist.
			// If it doesn't, it's a fundamental error in the A* implementation.
			gOfCurrent, ok := gScore[currentKey]
			if !ok {
				log.Printf("Pathfinding CRITICAL ERROR: Node %s popped from openSet but its gScore is missing. This should not happen.", currentKey)
				continue // Skip this node to prevent panic, though ideally this should not happen.
			}

			if current.X == candidateEndNode.X && current.Y == candidateEndNode.Y {
				// Path found for this candidate, reconstruct it using absolute maze coordinates
				pathMaze := []struct{ X, Y int }{}
				currentPathNode := current
				for currentPathNode != nil {
					pathMaze = append(pathMaze, struct{ X, Y int }{X: currentPathNode.X, Y: currentPathNode.Y})
					currentPathNode = cameFrom[fmt.Sprintf("%d,%d", currentPathNode.X, currentPathNode.Y)]
				}
				// Reverse the pathMaze to get it from start to end
				for i, j := 0, len(pathMaze)-1; i < j; i, j = i+1, j-1 {
					pathMaze[i], pathMaze[j] = pathMaze[j], pathMaze[i]
				}

				// Convert absolute maze path to world path
				pathWorld := make([]struct{ X, Y float64 }, len(pathMaze))
				if len(pathMaze) > 0 {
					// The first point in the path should be the player's actual current world position.
					pathWorld[0].X = startWorldX
					pathWorld[0].Y = startWorldY

					for i := 1; i < len(pathMaze); i++ {
						absoluteMazeX := pathMaze[i].X
						absoluteMazeY := pathMaze[i].Y

						// Convert absolute maze coordinates directly to world coordinates
						worldX, worldY := ns.MazeToWorldCoords(absoluteMazeX, absoluteMazeY)
						pathWorld[i].X = worldX
						pathWorld[i].Y = worldY
					}
				}

				// Calculate actual world distance for this path
				currentPathLength := 0.0
				if len(pathWorld) > 1 {
					for i := 0; i < len(pathWorld)-1; i++ {
						p1 := pathWorld[i]
						p2 := pathWorld[i+1]
						currentPathLength += math.Sqrt(math.Pow(p2.X-p1.X, 2) + math.Pow(p2.Y-p1.Y, 2))
					}
				}

				if currentPathLength < minPathLength {
					minPathLength = currentPathLength
					bestPath = pathWorld
					log.Printf("Pathfinding: Found a shorter path to candidate absolute (%d,%d) with length %.2f.", candidateEndNode.X, candidateEndNode.Y, minPathLength)
				}
				break // Found path for this candidate, move to next
			}

			for _, dir := range neighborsDirs { // Corrected loop variable
				// Calculate absolute neighbor coordinates
				neighborX, neighborY := current.X+dir.dx, current.Y+dir.dy
				neighborKey := fmt.Sprintf("%d,%d", neighborX, neighborY)

				// Calculate wrapped neighbor coordinates for maze lookup (obstacle check)
				wrappedNeighborX := (neighborX % ns.MazeCellsX)
				if wrappedNeighborX < 0 {
					wrappedNeighborX += ns.MazeCellsX
				}
				wrappedNeighborY := (neighborY % ns.MazeCellsY)
				if wrappedNeighborY < 0 {
					wrappedNeighborY += ns.MazeCellsY
				}

				// Check maze boundaries and if it's an obstacle (using wrapped coordinates)
				if wrappedNeighborX < 0 || wrappedNeighborX >= ns.MazeCellsX ||
					wrappedNeighborY < 0 || wrappedNeighborY >= ns.MazeCellsY ||
					ns.SimplifiedMaze[wrappedNeighborY][wrappedNeighborX] == 1 {
					continue
				}

				tentativeGScore := gOfCurrent + dir.cost // Use gOfCurrent here

				if val, ok := gScore[neighborKey]; !ok || tentativeGScore < val {
					newNode := &AStarNode{X: neighborX, Y: neighborY} // Store absolute coordinates
					cameFrom[neighborKey] = current
					gScore[neighborKey] = tentativeGScore
					newNode.G = tentativeGScore
					newNode.H = heuristic(newNode, candidateEndNode, ns.MazeCellsX, ns.MazeCellsY)
					newNode.F = newNode.G + newNode.H

					foundInOpenSet := false
					for i, node := range currentOpenSet {
						if node.X == newNode.X && node.Y == newNode.Y {
							if newNode.F < node.F {
								currentOpenSet[i] = newNode
								heap.Fix(&currentOpenSet, i)
							}
							foundInOpenSet = true
							break
						}
					}
					if !foundInOpenSet {
						heap.Push(&currentOpenSet, newNode)
					}
				}
			}
		}
	}

	if bestPath == nil {
		log.Printf("Pathfinding: No path found to any valid destination.")
		return nil, fmt.Errorf("no path found")
	}

	log.Printf("Pathfinding: Best path found with %d steps and total length %.2f.\n", len(bestPath), minPathLength)
	return bestPath, nil
}
